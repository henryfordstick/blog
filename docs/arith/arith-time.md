# 复杂度分析
复杂度分析是整个算法学习的精髓，只要掌握了他，数据结构和算法的内容就掌握了一半。
- 为什么需要复杂度分析
- 大 O 复杂度表示法

## 为什么需要复杂度分析
我们通常需要衡量一个算法的执行效率，但是如果把代码跑一遍，然后统计，监控得到算法的执行时间
和占用空间的大小。这种方法叫做**事后统计法**。

这种方式有以下的不足：
- 测试结果非常依赖测试环境
- 测试结果受数据规模的影响很大

我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

## 大 O 复杂度表示法
算法的执行效率，粗略地讲，就是算法代码执行的时间，用"肉眼"得到一段代码的执行时间。
### 时间复杂度
![时间复杂度](/images/arith-time.jpg)
#### O(1)
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

#### O(logn)、O(nlogn)
```c
i=1; 
while (i <= n) { 
  i = i * 2;
}
```
从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)

O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)

#### O(m+n)、O(m*n)
```c
int cal(int m, int n) { 
    int sum_1 = 0; 
    int i = 1; 
    for (; i < m; ++i) { 
        sum_1 = sum_1 + i; 
    } 

    int sum_2 = 0; 
    int j = 1; 
    for (; j < n; ++j) { 
        sum_2 = sum_2 + j; 
    } 

    return sum_1 + sum_2;
}
```
m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)

### 空间复杂度分析
时间复杂度的全称是**渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系**。类比一下，空间复杂度全称就是**渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

![空间复杂度](/images/arith-times.jpg)

复杂度分析并不难，关键在于多练。

## 最好，最坏，平均，均摊时间复杂度
最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）
### 最好、最坏情况时间复杂度
上面我举的分析复杂度的例子都很简单，接下来我们来看一个稍微复杂的。
```c
// n表示数组array的长度
int find(int[] array, int n, int x) { 
    int i = 0; 
    int pos = -1; 
    for (; i < n; ++i) { 
        if (array[i] == x) pos = i; 
    } 
    return pos;
}
```
这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。
这段代码的复杂度是 O(n)，其中，n 代表数组的长度。

```c
// n表示数组array的长度
int find(int[] array, int n, int x) {
    int i = 0; int pos = -1; 
    for (; i < n; ++i) { 
        if (array[i] == x) { 
            pos = i; break; 
        } 
    } 
    return pos;
}
```
如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的

因此，**最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度**，
**最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度**。

### 平均情况时间复杂度
最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。

我还是借助刚才查找变量 x 的例子来给你解释。

要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，

我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。

一般我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

### 均摊时间复杂度
我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫**均摊时间复杂度**。均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们。







