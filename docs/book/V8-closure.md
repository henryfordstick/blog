# 12 | 延迟解析：V8 如何实现闭包
V8 执行 JS 代码需要经过两个阶段：**编译**和**执行**。那么在编译阶段，V8 不会把所有的代码编译以后再执行。
- 首先，JS 的代码可能非常多，一次性都编译会增加编译时间，严重影响首次执行 JS 代码的速度。这样会出现卡顿。
- 其次，解析完成的字节码和编译完成的机器码都会放在内存当中，一次性编译会造成内存占用。

所以 V8 实现了**惰性解析**。就是解析器在解析的过程中，遇到函数声明，会跳过函数内部代码，并不会为其生成 AST 和 字节码，仅仅
生成顶层代码的 AST 和字节码。

## 一、惰性解析的过程
下面给出一段 JS 代码，看看 V8 是怎么处理的？
```js
function foo(a,b) {
    var d = 100;
    var f = 10;
    return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5)
```
V8 处理时，会自上而下的解析，解析的过程中遇到 foo 函数，只是一个声明语句，V8就会将函数转化为函数对象。并没有解析和编译函数内部的代码。
![V8解析函数](/images/35ce3f6469a7024ca14d81b6c804044a.jpg)
继续往下，由于后续的代码都是顶层的代码，所以 V8 会为他们生成抽象语法树。
![生成顶层代码的抽象语法树](/images/e52476efb6ef924e74f470ead4970262.jpg)
代码解析完成以后，就会一步一步的执行表达式，接下来遇到 foo 函数的执行，就从函数对象中取出函数代码编译执行。

上面是一个惰性解析的大致过程，但是遇到闭包怎么办呢？

## 二、拆解闭包
首先闭包有三个基础的特性：
- 第一 JavaScript 语言允许在函数内部定义新的函数
- 第二 可以在内部函数中访问父函数中定义的变量
- 第三 因为函数是一等公民，所以函数可以作为返回值

## 三、闭包给惰性解析带来的问题
下面写一个经典的闭包：
```js
function foo() {
    var d = 20;
    return function inner(a, b) {
        const c = a + b + d;
        return c
    }
}
const f = foo()
```
- V8 会将全局执行上下文压入到调用栈中,然后进入执行 foo 函数的调用过程
- V8 会为 foo 函数创建执行上下文，执行上下文中包括了变量 d
- 然后将 foo 函数的执行上下文压入栈中
- foo 函数执行结束之后，foo 函数执行上下文从栈中弹出,这时候 foo 执行上下文中的变量 d 也随之被销毁
- 这时候，由于 inner 函数被保存到全局变量中了,inner 函数使用了 foo 函数中的变量 d ...😁

接下来问题就来了，在 foo 执行的阶段采用了惰性解析，不会解析 inner 函数的内容，怎么判断 inner 中使用了 foo 中的变量呢？

解决这个问题，V8 引入了预解析器。
- 第一判断当前函数是不是存在一些语法上的错误，如果有就抛出错误。
- 第二就是检查函数内部是否引用了外部变量，如果引用了，**预解析器就会将栈中的变量复制到堆中**。

## 四、总结
在编译阶段，v8不会对所有代码进行编译，要不然速度会很慢，严重影响用户体验，所以采用一种“惰性编译”或者“惰性解析”，也就是说 v8默认不会对函数内部的代码进行编译，只有当函数被执行前，才会进行编译。

而闭包的问题指的是：由于子函数使用到了父函数的变量，导致父函数在执行完成以后，它内部被子函数引用的变量无法及时在内存中被释放。

而闭包问题产生的根本原因是 javascript中本身的特性：
1. 可以在 JavaScript 函数内部定义新的函数；
2. 内部函数中访问父函数中定义的变量；
3. 因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。

既然由于javascript本身的这种特性就会出现闭包的问题，那么我们就要想办法解决闭包问题，那么“预编译“ 或者“预解析” 就出现了，

预编译具体方案： 在编译阶段，v8不会完全不解析函数，而是预解析函数，简单理解来说，就是判断一下父函数中是否有被子函数饮用的变量，如果有的话，就需要把这个变量copy一份到 堆内存中，同时子函数本身也是一个对象，它会被存在堆内存中，这样即使父函数执行完成，内存被释放以后，子函数在执行的时候，依然可以从堆内存中访问copy过来的变量。



