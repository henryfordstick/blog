# 第二章 正则表达式位置匹配攻略
正则表达式是匹配模式，要么匹配字符，要么匹配位置。
- 一、什么是位置
- 二、位置的特性
- 三、相关案例

## 一、什么是位置
位置（锚）是相邻字符之间的位置。

其中ES5中，位置匹配有六种：
`^`,`$`, `\b`, `\B`, `(?=p)`, `(?!p)`。

#### 1、`^`和`$`
`^`（脱字符）匹开头，在多行匹配中匹配行开头。<br/>
`$`（美元符号）匹结尾，在多行匹配中匹配结尾。
```js
var result = 'hello'.replace(/^|$/g, '#');
console.log(result);
// #hello#

// 多行匹配 m修饰符表示多行匹配模式
var result = 'I\nlove\njavascript'.replace(/^|$/gm, '#');
console.log(result);
/*
#I#
#love#
#javascript#
*/
```
:::tip
`m`修饰符表示多行匹配模式
:::

#### 2、`\b`和`\B`
`\b`是边界，即 `\w` 和 `\W` 之间的位置，同时包括`\w`和`^`之间的位置，`\w`和`$`之间的位置。
```js
var result = '[JS] Lesson_01.mp4'.replace(/\b/g, '#');
console.log(result);
// [#JS#] #Lesson_01#.#mp4#

// 分析
// 1、两边字符 '[' 与 ']', 是 \W 与 \w 之间的位置
// 2、两边字符是 "S" 与 "]"，也就是 \w 与 \W 之间的位置
// 3、两边字符是空格与 "L"，也就是 \W 与 \w 之间的位置。
// 4、两边字符是 "1" 与 "."，也就是 \w 与 \W 之间的位置
// 5、两边字符是 "." 与 "m"，也就是 \W 与 \w之间的位置
// 6、位于结尾，前面的字符 "4" 是 \w，即 \w 与 $ 之间的位置
```
`\B` 就是 `\b` 反面的意思，非单词边界。即字符串中所有位置中，除去`\b`，剩下的就是 `\B`。
```js
var result = '[JS] Lesson_01.mp4'.replace(/\B/g, '#');
console.log(result);
// #[J#S]# L#e#s#s#o#n#_#0#1.m#p#4
```

#### 3、`(?=p)`和`(?!p)`
`(?=p)`（**正向先行断言** positive lookahead）表示 p 是一个子模式， 即 p 前面的位置。或者该位置后面匹配 p。<br/>
`(?!p)`（**负向先行断言** negative lookahead）即 `(?=p)` 的反面意思。
```js
var result = 'hello'.replace(/(?=l)/g, '#');
console.log(result);
// he#l#lo

var result = 'hello'.replace(/(?=l)/g, '#');
console.log(result);
// #h#ell#o#
```
:::tip 先行断言和后行断言
- `(?=p)` **正向先行断言**（positive lookahead）代表匹配改位置之后的序列能够匹 p
- `(?!p)` **负向先行断言**（negative lookahead）代表匹配改位置之后的序列不能够匹 p
- `(?<=p)` **正向后行断言** (positive lookbehind) 代表匹配改位置之前的序列能够匹 p
- `(?<!p)` **负向后行断言** (negative lookbehind) 代表匹配改位置之前的序列不能够匹 p

1、关于**先行和后行**：正则表达式引擎在执行字符串和表达式的时候，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。<br/>
先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。<br/>
后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。

2、关于**正向和负向**：正向就表示匹配括号中的表达式，负向表示不匹配。
:::

## 二、位置的特殊性
对于位置，我们可以理解成空字符串 `""`。
```js
// hello 字符串等价如下形式
"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + "";
"hello" == "" + "" + "hello"
```
:::tips
把位置理解空字符，是对位置最有效的理解方式。
:::
## 三、相关案例
#### 1、不匹配任何东西的正则
```js
// 分析
// 正则要求只有一个字符，但该字符后面是开头，这样的字符串是不存在的

/.^/
```
#### 2、数字的千位分隔符表示法
```js
// 要求
// 把 "12345678"，变成 "12,345,678"

// 分析
// 1、先添加最后一个逗号 /(?=\d{3}$)/g
"12345678".replace(/(?=\d{3}$)/g, ',') // "12345,678"

// 2、添加所有的逗号，要求 3 个一组，(\d{3})+
"12345678".replace(/(?=(\d{3})+$)/g, ',') // "12,345,678"
// "123456789" 就变成了 ",123,456,789"，这里有问题

// 3、那么要求匹配不能是开头
"123456789".replace(/(?!^)(?=(\d{3})+$)/g, ',') // "123,456,789"

// 4、如果有其他形式 "12345678 123456789",那么 (?!^) 只能改成 (?!\b) 不是 \b 前面的位置即 \B（不能是\w 和 \W 之间的位置）
"12345678 123456789".replace(/(?!\b)(?=(\d{3})+\b)/g, ',') // "12,345,678 123,456,789"
// 简化为
/\B(?=(\d{3})+\b)/g

// 5、格式化，千分符表示法就是货币格式化。 如 1888 改成 $ 1888.00
function format (num) {
  return num.toFixed(2).replace(/\B(?=(\d{3})+\b)/, ',').replace(/^/, '$$ ');
}
```
#### 3、验证密码问题
```js
// 要求
// 密码长度为 6-12 位，由数字，小写字符，大写字母组成，但至少包括 2 种字符

// 分析
// 1、简化一下，不考虑 "但至少包括 2 种字符"
/^[0-9A-Za-z]{6,12}$/

// 2、判断是否包含一种字符 (?=.*[0-9])
/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/

// 3、判断同时包含数字和小写字母 (?=.*[0-9])(?=.*[a-z])
/(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/

// 4、判断同时包含两种字符 ① 数字和小写  ② 数字和大写 ③ 小写和大写 ④ 数字，小写和大写
/((?=.*[0-9])(?=.*[a-z]))|((?=.*[0-9])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/

// 5、另一种解法，不能全部都是数字 (?!p)
/(?!^[0-9]{6,12})(?!^[a-z]{6,12})(?!^[A-Z]{6,12})^[0-9A-Za-z]{6,12}$/
```