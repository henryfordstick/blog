# 第四章 正则表达式回溯法原理
回溯也称为试探法，本质上就是深度优先搜索算法，其中退到之前的某一步这一过程，称为”回溯“。
- 一、没有回溯的匹配
- 二、有回溯的匹配
- 三、常见的回溯形式
  
## 一、没有回溯的匹配
```js
/ab{1,3}c/
// b{1,3}表示 b 字符连续出现 1 到 3 次
// 匹配 abbbc 的时候就没有回溯
```
![没有回溯的匹配](/images/regex-回溯1.png)
## 二、有回溯的匹配
##### 案例一
如果继续使用 `/ab{1,3}c/`，将上面案例中的 `abbbc` 改成 `abbc` 中间就有回溯了，具体回溯过程如下图所示：
![有回溯的正则](/images/regex-回溯2.png)
1. 正则从首位开始匹配字符串
2. 正则中的 a 匹字符串中的 a
3. 正则中的 b{1,3} 匹配字符串中的第一个 b
4. 正则中的 b{1,3} 匹配字符串中的第二个 b
5. 正则中的 b{1,3} 匹配字符串中的 c 时，不匹配，这里就产生**回溯**
6. 这时就认为 b{1,3} 已经匹配完毕，然后状态回到之前的状态，即第 4 步
7. 最后用正则中的 c 匹配字符串中的 c，这时整个表达式匹配成功了。

##### 案例二
接下来把上例的正则改一下，`/ab{1,3}bbc/` 匹配 abbbc，匹配的过程如下：
![有回溯的正则2](/images/regex-回溯3.png)
1. 正则从首位开始匹配字符串
2. 正则中的 a 匹字符串中的 a
3. 正则中的 b{1,3} 匹配字符串中的第一个 b
4. 正则中的 b{1,3} 匹配字符串中的第二个 b
5. 正则中的 b{1,3} 匹配字符串中的第三个 b
6. 正则中的 b{1,3} 后面的 b 匹配字符串中的 c 时，不匹配
7. 这里进行回溯，回到第 4 步
8. 正则中的 b{1,3} 后面的第一个 b 匹配字符串中第三个 b
9. 正则中的 b{1,3} 后面的第二个 b 匹配字符串中的 c 时，不匹配
10. 这里进行回溯，回到第 3 步
11. 正则中的 b{1,3} 后面的第一个 b 匹配字符串中的第二个 b
12. 正则中的 b{1,3} 后面的第二个 b 匹配字符串中的第三个 b
13. 正则中的 b{1,3} 后面的 c 匹配字符串中的 c，这时整个表达式匹配成功了。

##### 案例三
正则中的 `.*` 是非常影响效率的，接下来利用 `/".*"/` 来匹配 "abc"de 分析一下过程
![有回溯的正则3](/images/regex-回溯4.png) 
:::tip
上面的正则改成 `/"[^"]"/` 就会避免不必要的回溯。
:::

## 三、常见的回溯形式
前面着重介绍什么是回溯，那么那些情况可以产生回溯呢？
#### 1、贪婪量词
之前的例子中 `b{1,3}`，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。

那么将多个量词挨着存在，并相互冲突时，会怎么样？
```js
var string = "12345";
var regex = /(\d{1,3})(\d{1,3})/
console.log(string.match(regex));
// ['12345','123','45', index: 0, input: '12345']
```
上面结果是第一个 `\d{1,3}` 匹的是 123， 而第二个 `\d{1,3}` 匹的是 45。所以可以得出的结论是**先下手为强，因为是深度有限搜索**。

#### 2、惰性量词
惰性量词就是在贪婪量词后面加个问号，表示尽可能少的匹配
```js
var string = '12345';
var regex = /(\d{1,3}?)(\d{1,3})/;
console.log(string.match(regex));
// ['12345','1','234', index: 0, input: '12345']
```
因为前面 `\d{1,3}?` 是惰性的，所以只给匹配了 1，那么怎么回溯呢？
```js
var string = '12345';
var regex = /^(\d{1,3}?)(\d{1,3})$/;
console.log(string.match(regex));
// ['12345', '12', '345', index: 0, input: '12345', groups: undefined]
```
这里加入了 ^ 和 $， `\d{1,3}?` 匹配的结果就成了 12 了，**原因是知道你不贪，很知足，但是为了整体的利益，只能给你多塞一个了**。

#### 4、分支结构
分支结构会一个一个去尝试，如果前面的满足了，后面的就不会再试验了，这种尝试也可以看成是一种回溯。
```js
var string = "candy";
var regex = /can|candy/;
console.log(string.match(regex));
// ['can', index: 0, input: 'candy', groups: undefined]

// 如果正则改成下面的呢
var regex = /^(?:can|candy)$/
// ['candy', index: 0, input: 'candy', groups: undefined]
// 第一个分支不满意，就去匹配第二个分支
```
下面就是 `/^(?:can|candy)$/` 回溯流程图
![分支结构的回溯](/images/regex-回溯5.png)
:::tip DFA 和 NFA
回溯的效率低一些，但是相对谁？
- DFA引擎 （确定型有限自动机） 
- NFA引擎 （非确定性有限自动机）

DFA中回溯就会快，但是不支持断言。具体详细可以研究编译原理，这里先挖个坑！！！
:::