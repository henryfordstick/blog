# 11 | 堆和栈
在开始之前，看三段代码：
```js
function foo() {
 foo() // 是否存在堆栈溢出错误?
}
foo()
```
```js
function foo() {
  setTimeout(foo, 0) // 是否存在堆栈溢出错误?
}
```
```js
function foo() {
    return Promise.resolve().then(foo)
}
foo()
```
这三段代码的执行结果是：第一段造成栈溢出，第二段能够正确执行，第三段没有栈溢出的错误，但是造成页面卡死。

主要的原因是这三段代码的底层执行逻辑不一样：
- 第一段代码是在同一个任务中重复调用嵌套的 foo 函数；
- 第二段代码是使用 setTimeout 让 foo 函数在不同的任务中执行；
- 第三段代码是在同一个任务中执行 foo 函数，但是却不是嵌套执行。

因为这三段代码内部布局是不同的，不同的内存布局又会影响到代码的执行逻辑。接下来我们从函数的特征入手，来一步步延伸出通用的函数调用模型，进而来分析不同的函数调用方式是如何影响到运行时内存布局的。
![函数调用的堆和栈](/images/d540183ab23341f568b992881edaa709.jpg)

## 一、使用栈结果来管理函数调用
先说说函数有两个重要的特征：
- 第一个是函数**可以被调用**，可以在一个函数中调用另外一个函数，当函数调用时，将执行代码的控制权从父函数转移到
子函数，子函数执行结束后，又会将代码执行控制权返给父函数。

- 第二个是函数**具有作用域机制**，就是函数在执行的时候可以将定义在内部的变量和外部环境隔离，在函数内部定义的变量
我们称为**局部变量**，当改函数执行完以后，局部变量也随之被销毁。
```c
int getZ(){
    return 4;
}
int add(int x,int y){
    int z = getZ();
    return x + y + z;
}
int main(){
    int x = 5;
    int y = 6;
    int ret = add(x + y);
}
/*
 以上函数的执行流程如下：
 1、当 main 函数调用 add 函数时，需要将控制权交给 add 函数
 2、然后 add 函数又调用 getZ 函数，又将控制权交给 getZ 函数
 3、接下来 getZ 函数执行完成，需要将控制权返回给 add 函数
 4、当 add 函数执行结束后，需要将控制权返回给 main 函数
 5、然后 main 函数继续向下执行
 */
```
函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者的生命周期结束 (先出)。
![嵌套调用时函数的生命周期](/images/a3cfa1ad1d6eb6be321355c191b76fdb.jpg)
而站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数 (后进)，而函数资源的释放则总是先于调用函数 (先出)。
![函数资源分配流程](/images/f8aab2c91e5f29c275317cbfc02a4e99.jpg)

## 二、栈管理函数调用
```c

int add(num1,num2){
    int x = num1;
    int y = num2;
    int ret = x + y;
    return ret;
}

int main()
{
    int x = 5;
    int y = 6;
    x = 100;
    int z = add(x,y);
    return z;
}
```
将上面的 main 函数在栈中调用的场景如下图所示：
![函数内部变量压栈状态](/images/27f1a623219737f376deddfefb865478.jpg)
函数在执行过程中，其内部的临时变量会按照执行顺序被压入到栈中。

接下来调用 add 函数了
![add函数](/images/27407a5f9089c4a8b09c0d2b775b50b1.jpg)
当 add 函数执行完以后将权限交给 main 函数上次执行的状态，这个过程叫**恢复现场**。那么具体怎么恢复的呢？

在寄存器中始终保存一个永远指向当前栈顶的指针，这个指针放在 esp 寄存器中。如果往栈中添加一个元素，那么需要根据 esp
寄存器的地址找到栈顶的位置，然后添加新元素，新元素添加以后，将新元素的地址更新到 esp 寄存器中。当 add 函数执行完以后
只需要将栈顶指针向下移动就可以了。
![add函数即将执行结束的状态](/images/68b9d297cc48864ad49c1915766fa6bd.jpg)
恢复 main 函数执行现场如下图：
![恢复 main 函数执行现场](/images/89180f0674a92df96ce6f25813020ed2.jpg)
那么问题由来了，CPU 怎么知道要移动这个指针呢？

解决方法是增加另一个 epb 寄存器，用来保存当前函数的起始位置，ebp 寄存器中保存的就是当前函数的栈帧指针。
![ebp寄存器保存了栈帧指针](/images/94e1333f053d4dbbb41eb00aaf869a91.jpg)
main 函数调用 add 函数时，将 main 函数的栈顶指针是保存在 ebp 中。当 add 执行结束后，将 ebp 中保存的 main 栈顶指针回写到 esp
中（相当于将栈顶指针移动到 main 函数区域），最后将栈帧地址取出来保存在 ebp 中。
![栈帧地址](/images/30dc7c253b8d0ffb332cfb7a878ebe9c.jpg)
:::tip 栈顶指针和栈帧地址
- 栈帧中保存了该函数的返回地址和局部变量。
- 栈顶指针当前栈顶的指针。
:::tip 详细解释文章开头的三段代码
第一段 foo不断的调用 foo 自身，这样就会导致栈无限增，进而导致栈溢出的错误。

第二段 使用了 setTimeout （宏任务）使用 foo 排到消息队列后面的任务中执行，不会影响栈结构，也不会溢出。

第三段 使用了 Promise （微任务）会不断的添加任务并执行（一直创建执行），这样就不会造成栈溢出，但会造成主线程卡死。
:::

## 三、有了栈，为什么还要堆呢
先看看栈的优点：
- 栈的结构和非常适合函数调用过程
- 在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。

由上面的优点就造成了栈的缺点：就是栈是连续的，需要分配连续的大空间是非常难得，因此栈空间是有限的。

所以使用了另外一种数据结构保存一些大数据，这就是**堆**。堆中的数据是不要求连续存放的，内存块也没有固定模式，可以在任何时候
分配和释放它。通常我们在堆中存放数据内容，将堆中的地址存放在栈中。











