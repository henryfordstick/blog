# 10 | 机器代码
当 V8 准备好 runtime 以后，就可以执行 JS 代码了。V8 需要将 源代码 解析成字节码，然后执行，
或者将需要优化的代码直接编译成机器码，并直接执行机器码。

字节码和机器码的执行方式是一样的。那么问题是 CPU 是怎么执行机器码（二进制代码的）？
![CPU执行二进制代码](/images/a20dec9ec8a84c8519dd1c4a18c2dda2.jpg)

## 一、源码编译成机器码
将一段 c 语言代码编译成汇编代码。
```c
// 在文件夹下创建 index.c 文件，内容如下：
int main(){
    int x = 1;
    int y = 2;
    int z = x + y;
    return z;
}
```
先通过 GCC 编译器编译成 二进制文件，再反汇编成汇编代码（将汇编代码转换成机器代码称为**汇编**，反之机器码转化成汇编称为**反汇编**）。
```bash
gcc -O0 -o code_prog index.c
objdump -d code_prog
```
![机器码和汇编码](/images/45a51ccfeba212d1ccda8c669d317509.png)
- 上图中，左边就是编译生成的机器码，是使用十六进制来展示的（十六进制易读），
- 中间部分是汇编代码，汇编采用**助记符**来编写代码，其内容和机器码是一一对应的。
## 二、CPU 是怎么执行程序的
在讨论这个问题之前，我们看看典型的计算机系统的硬件组织结构。
![计算机系统的硬件组织结构](/images/880dc63d333d8d18d8be9a473b15e06d.jpg)
主要有 CPU，主存储器，各种 IO 总线，还有一些外部设备如硬盘，显示器，USB 等。

**首先，在执行程序之前，需要将程序装进内存**。
:::tip 内存，内存地址和 CPU
一个恰当的比喻：
- 把内存看成快递柜，当你需要寄件是，打开快递柜的第 100 单元格。
- 当你需要取件时，打开快递柜的 105 号单元格取件。

这里的 **快递柜**，**快递柜的每个单元格编号** 和 **操作快递柜的人** 分别就是 **内存**，**内存地址**和**CPU**。

也就是说，CPU 可以指定内存地址，从内存地址中读取数据，或者往内存地址中写入数据。

有了内存地址，CPU 和内存可以有序的交互。
:::
**内存中的每个存储空间都有其对应的独一无二的地址**。下图展示：
![内存中的存储空间都有唯一地址](/images/87bfd9f3cd9a3e120e9e51a47fb4afe6.jpg)

一旦二级制代码装进内存，CPU 便可以从内存中**取出一条指令**，然后分析该指令，最后**执行该指令**。
（我们把取出指令，分析指令，执行指令三个过程称为**CPU时钟周期**）。CPU永不停歇，一直重改这个过程，直至所有的
指令执行完成。

那么 CPU 是怎么知道要取出哪个内纯地址的指令呢？
![将混乱的二进制代码转换为有序的指令形式](/images/81f37939dc9920c1e0e261c7f345ceb3.jpg)

**CPU 中是有一个 PC 寄存器，它保存了将要执行的指令地址**。当机器码装进内存以后，系统会将机器码的第一条指令的地址
写入寄存器，下一个时钟周期 CPU 便根据 PC 寄存器中的地址，到内存中取出指令。

PC 寄存器中的指令取出来以后，系统将干两件事：
- 第一将下一条指令的地址更新到 PC 寄存器中。
- 第二 CPU 分析该指令并识别出不同的类型的指令，以及各种获取操作数的方法。
![将下一条指令写入PC中](/images/10e900db99f77fa780ef4652b8302f42.jpg)

那么 CPU 是如何执行指令的呢？

这里需要一个重要部件：**通用寄存器** 是 CPU 存放数据的设备，不同处理器的寄存器个数是不一样的；因为 CPU 访问
内存的速度很慢，所以在 CPU 内部添加了一些存储设备，就叫通用寄存器。

:::tip 通用寄存器和内存
- **通用寄存器容量小，读写速度快，内存容量大，读写速度慢。**
- 通常寄存器存储的数据是没有特别限制的（既可以存储数据，又可以存储指针）。但是因为历史原因，会将专用的数据放在专用的寄存器中。
    - rbp 寄存器通常是用来存放栈帧指针的。
    - rsp 寄存器用来存放栈顶指针的。
    - PC 寄存器用来存放下一条要执行的指令。
:::
常见的指令类型有哪些呢？

第一种是**加载指令**，其作用是从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容。
![更新PC寄存器](/images/c058013ef04fae7c1d5ff24cf0911fed.jpg)
如上图 **movl**指令，指令后面跟着的第一个参数是要拷贝数据的内存的位置，第二个参数是要拷贝到 ecx 这个寄存器。

第二种是**存储的指令**，和加载类型的指令相反，其作用是将寄存器中的内容复制内存某个位置，并覆盖掉内存中的这个位置上原来的内容。
![存储的指令](/images/5dc3e0cf2ffba709280bb852ea37891e.jpg)
movl 指令后面的 %ecx 就是寄存器地址，-8(%rbp) 是内存中的地址，这条指令的作用是将寄存器中的值拷贝到内存中。

第三种是**更新指令**，作用是复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容。
![更新指令](/images/8fde0c5d8d139060849531e5537111fb.jpg)
addl 指令，将寄存器 eax 和 ecx 中的值传给 ALU，ALU 对它们进行相加操纵，并将计算的结果写回 ecx。

第四种是**跳转指令**，从指令本身抽取出一个字，这个字是下一条要执行的指令的地址，并将该字复制到 PC 寄存器中，并覆盖掉 PC 寄存器中原来的值。
![跳转指令](/images/a69affcd27b2646fff920a0c0ab08aca.jpg)
通过 jmp 来实现的，jmp 后面跟着要跳转的内存中的指令地址。

第五种是**IO 读 / 写指令**，这些指令可以从一个 IO 设备中复制指定长度的数据到寄存器中，也可以将一个寄存器中的数据复制到指定的 IO 设备。

## 三、总结
CPU 执行二进制代码的过程如下：
1. 二进制代码装载进内存，系统会将第一条指令的地址写入到 PC 寄存器中。
2. 读取指令：根据pc寄存器中地址，读取到第一条指令，并将pc寄存器中内容更新成下一条指令地址。
3. 分析指令：并识别出不同的类型的指令，以及各种获取操作数的方法。
4. 执行指令：由于cpu访问内存花费时间较长，因此cpu内部提供了通用寄存器，用来保存关键变量，临时数据等。指令包括加载指令，存储指令，更新指令，跳转指令。如果涉及加减运算，会额外让ALU进行运算。
5. 指令完成后，通过pc寄存器取出下一条指令地址，并更新pc寄存器中内容，再重复以上步骤。








