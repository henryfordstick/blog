# 04 | 函数表达式
函数声明和函数表达式这两个概念容易混淆，所以下面就详细解释一下。
![函数声明和函数表达式](/images/51ae06e8a9dc4a589958065429bec231.jpg)

## 一、函数声明和函数表达式的区别
先看看函数声明的代码
```js
foo();
function foo(){
  console.log('foo');
}

// foo
```
然后看看函数表达式的代码
```js
foo();

var foo = function() {
  console.log('foo');
}

// 报错 foo is not a function
```
上面的结果中，为什么函数声明可以执行，函数表达式却报错了呢？

V8 执行的过程中分为两个阶段：编译和执行
编译阶段，将所有的变量提升到作用域的过程称为变量提升。
- 函数声明会直接提升到执行语句的前边去。
- 函数表达式 却只会提升 函数的变量名称 `foo = undefined`

函数声明并不是一个表达式，而是一个语句。所以在变量提升阶段，V8 会对函数声明执行变量提升。

函数表达式，编译阶段只会将对象提升，并赋值为 undefined，对象的内容并不会提升。
在执行的时候才会按顺序将内容赋值给对象身上。

主要是不同的语义，触发了不同的行为
![不同的语义，触发不同的行为](/images/a74668eb5bf183538ce9b47a20eb0610.jpg)

## 二、立即调用的函数表达式（IIFE）
在编译阶段，V8不会处理函数表达式的，立即执行函数正是使用了这一特性。

JS 中圆括号里面可以放一个表达式，如果在里面放一个函数，这个函数也会被看成函数表达式。
然后再表达式后面加上调用，就变成了 IIFE。

因为 IIFE 在编译阶段不会创建函数对象，这样的一个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到。

## 三、经典面试题
```js

var n = 1;
(function foo(){
    n = 100; // 这里 n 找不到，会到上层作用域找
    console.log(n);
}());
console.log(n); // 因为 IIFE 已经改变 n 的值

// 100 100
```
```js
var n = 1;
function foo(){
    n = 100;
    console.log(n);
}
console.log(n); // 这里函数没有执行，所以为1
foo() // n 为100，没有争议

// 1 100
```




