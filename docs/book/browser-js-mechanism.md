# 第三章 浏览器中 JS 执行机制
前面对浏览器宏观原理做了一个深度介绍，接下来我们深入一下 JS 的执行原理。

## 一、变量提升原理
```js
showName()
console.log(myname);
var myname = '极客时间'
function showName () {
  console.log('函数 showName 被执行');
}

// 函数 showName 被执行
// undefined

// 当去掉 “var myname = '极客时间'” 这段代码时，js 引擎就会报错
// myname is not defined
```
1. 在执行过程中，使用了未声明的变量， JS 会报错
2. 在变量定义之前使用它，不会报错，值为 undefined
3. 在函数定义之前使用，不会报错，且函数能正确执行

#### 1、变量提升
在学习变量提升之前要知道什么是 JS 中的 **声明** 和 **赋值**。<br/>
变量和函数都要经历这两个步骤，先看变量：
```js
var myname = '极客时间'
// 这段代码实际可以看成两行代码组成
var myname = undefined; // 声明部分
myname = '极客时间' // 赋值部分
```
接下来是函数：
```js
function foo () {
  console.log('foo');
}

var bar = function () {
  console.log('bar');
}

// 上面 foo 函数属于函数声明，没有涉及到赋值操作
// bar 函数则可以分为一下两部分
var bar = undefined; // 声明

bar = function () { // 赋值
  console.log('bar');
}
```
**所谓变量提升，就是 JS 代码在执行的过程中， JS 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。**变量
被提升后，会给变量默认值 undefined<br/>
```js
// 开头那段代码可以分为两部分
// **********变量提升部分************
var mynane = undefined;
function showName () {
  console.log('showName 被调用');
}

// ***********可执行代码部分************
showName();
console.log(myname);
myname = '极客时间'
```
由此可以看出函数声明和变量在执行之前都提升到了代码开头。

#### 2、JS 代码的执行流程
上面的代码仅供理解，写出了’等效代码‘。实际上**变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JS 引擎放入内存中**，也就是说 一段代码先要经过 JS 引擎编译，完成后才会进入执行阶段。

**编译阶段**
会将代码分成 （1）变量提升部分的代码 （2）执行部分的代码
![js执行流程图](/images/browser-js1.png)
一段代码经过编译后，会生成两部分内容：**执行上下文和可执行代码**<br/>
执行上下文：执行一段代码时的运行环境，如函数，就会确定该函数在执行期间用到的诸如 this 、变量、对象及函数。

**执行阶段**
JS 引擎开始执行“可执行代码”，按照顺序一行一行地执行。
```js
// ***********可执行代码部分************
showName();
console.log(myname);
myname = '极客时间'
```
- 执行 showName 函数时，JS 引擎便开始在变量环境对象中查找函数，如果存在，引擎便开始执行该函数，并输出执行结果
- 接下来打印 "myname" ，引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，值为 undefined
- 将 “极客时间” 赋值给 myname 变量

#### 3、代码中存在相同的变量或者函数怎么办
一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。

## 二、调用栈
什么情况下代码才会在执行前就进行编译和创建上下文呢？
1. 当 JS 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况函数执行结束后才会销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

那么代码中经常会出现一个函数调用另一个函数的情况，**调用栈就是用来管理函数调用关系的一种数据结构**。

#### 1、什么是函数调用
函数调用就是运行一个函数，如:
```js
var a = 2;
function add() {
  var b = 10;
  return a + b
}
```
- 先从全局上下文中 取出 add 函数
- 对 add 函数进行编译，并创建**该函数的执行上下文**和**可执行代码**
- 最后，执行代码，输出结果。

那么可能存在多个执行上下文， JS 引擎是通过一种叫栈的数据结构来管理的。

#### 2、栈和 JS 调用栈
栈 只有一个出入口，类似一个杯子， 后进先出。<br/>
JS 引擎会将执行上下文压入栈中，这种管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。
```js
var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
var d = 10
result = add(b,c)
return  a+result+d
}
addAll(3,6)
```

1. 第一步，创建全局上下文，并将其压入栈底。将 变量 a，函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。
2. 第二步，调用 addAll 函数。 当调用改函数时，JS 引擎会编译该函数，并为其创建一个执行上下文，最后将该函数的执行上下文压入栈中。
3. 第三步，当执行到 add 函数，同样会为其创建执行上下文，并将其压入调用栈
4. 第四步，将栈中的函数执行完并从栈顶弹出，只剩下全局上下文。

调用栈是 JS 引擎追踪函数执行的一个机制。

#### 2、在开发中，如何利用好调用栈
1. 如何利用浏览器查看调用栈的信息





