<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React Native 原理浅析 | 渔网的收获</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/user.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.f85f523a.css" as="style"><link rel="preload" href="/assets/js/app.596f9c08.js" as="script"><link rel="preload" href="/assets/js/2.55845630.js" as="script"><link rel="preload" href="/assets/js/33.621a195e.js" as="script"><link rel="preload" href="/assets/js/3.e0f79c9f.js" as="script"><link rel="prefetch" href="/assets/js/10.81c55362.js"><link rel="prefetch" href="/assets/js/11.a8961898.js"><link rel="prefetch" href="/assets/js/12.27d273d8.js"><link rel="prefetch" href="/assets/js/13.17b526ee.js"><link rel="prefetch" href="/assets/js/14.9fb9f1f6.js"><link rel="prefetch" href="/assets/js/15.68809f88.js"><link rel="prefetch" href="/assets/js/16.aba76e28.js"><link rel="prefetch" href="/assets/js/17.935024df.js"><link rel="prefetch" href="/assets/js/18.87e02b1b.js"><link rel="prefetch" href="/assets/js/19.9ce88a57.js"><link rel="prefetch" href="/assets/js/20.153bc889.js"><link rel="prefetch" href="/assets/js/21.c6d8215f.js"><link rel="prefetch" href="/assets/js/22.1e61390a.js"><link rel="prefetch" href="/assets/js/23.7ec11354.js"><link rel="prefetch" href="/assets/js/24.9cb6f350.js"><link rel="prefetch" href="/assets/js/25.26af678e.js"><link rel="prefetch" href="/assets/js/26.257a042b.js"><link rel="prefetch" href="/assets/js/27.7b4ab38d.js"><link rel="prefetch" href="/assets/js/28.e64b7c0b.js"><link rel="prefetch" href="/assets/js/29.0979406b.js"><link rel="prefetch" href="/assets/js/30.fe5a4276.js"><link rel="prefetch" href="/assets/js/31.797bcde4.js"><link rel="prefetch" href="/assets/js/32.3cfb5af5.js"><link rel="prefetch" href="/assets/js/34.a17ff68f.js"><link rel="prefetch" href="/assets/js/35.98958db5.js"><link rel="prefetch" href="/assets/js/36.9d8c8f04.js"><link rel="prefetch" href="/assets/js/37.14e93bdb.js"><link rel="prefetch" href="/assets/js/38.13542f75.js"><link rel="prefetch" href="/assets/js/4.7c53c391.js"><link rel="prefetch" href="/assets/js/5.d6b23f0c.js"><link rel="prefetch" href="/assets/js/6.da3f1227.js"><link rel="prefetch" href="/assets/js/7.2b2bf1e6.js"><link rel="prefetch" href="/assets/js/8.a9d9e867.js"><link rel="prefetch" href="/assets/js/9.79800cc0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f85f523a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">渔网的收获</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/arith/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://github.com/henryfordstick" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/arith/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://github.com/henryfordstick" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>视野拓展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/expand-browser.html" class="sidebar-link">浏览器原理浅析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Framework</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react-library.html" class="sidebar-link">React 使用总结</a></li><li><a href="/blog/react-library-core.html" class="sidebar-link">React 核心知识</a></li><li><a href="/blog/react-source-one.html" class="sidebar-link">React 源码分析（一）JSX 转换</a></li><li><a href="/blog/react-native.html" class="sidebar-link">React Native 使用总结</a></li><li><a href="/blog/react-native-bridge.html" class="sidebar-link">React Native 桥接之路</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML/CSS</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js-undefined-null.html" class="sidebar-link">null 和 undefined 区别</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/internet-movement.html" class="sidebar-link">互联网是如何运作的</a></li><li><a href="/blog/internet-osi.html" class="sidebar-link">理解 OSI 模型和 TCP/IP 模型</a></li><li><a href="/blog/internet-http.html" class="sidebar-link">HTTP 协议总结</a></li><li><a href="/blog/internet-https.html" class="sidebar-link">HTTPS 协议总结</a></li><li><a href="/blog/internet-tcp.html" class="sidebar-link">TCP 协议总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/basis-ts1.html" class="sidebar-link">深入 TypeScript 系列（一）</a></li><li><a href="/blog/basis-ts2.html" class="sidebar-link">深入 Typescript 系列（二）</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-native-原理浅析"><a href="#react-native-原理浅析" class="header-anchor">#</a> React Native 原理浅析</h1> <p>这章来讲讲 React Native 的原理，来揭开它的神秘面纱！</p> <ul><li>一、JavaScriptCore</li> <li>二、浏览器工作原理</li> <li>三、React Native 架构</li> <li>四、React Native，React 和 JavaScriptCore 的关系</li> <li>五、Bridge 各模块简介</li> <li>六、相关链接</li></ul> <p>关于 React Native 的更新，可以查看<a href="https://juejin.im/post/6844904146840059918" target="_blank" rel="noopener noreferrer">JS 核心理论之《 原理浅析》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="一、javascriptcore"><a href="#一、javascriptcore" class="header-anchor">#</a> 一、JavaScriptCore</h2> <p>为什么要说 JS Engine 呢？<strong>因为 React Native 的核心代码都是用 JS 来写的，没有 JS Engine，
那么我们所写的 JS 和 JSX 代码都无法执行，更无法驱动 Native 的 API 了</strong>。
<code>JavaScriptCore</code>是 iOS 设备默认支持的，是 Webkit 默认的 JS 引擎，所以 iOS 和 Android 都支持。</p> <p>现在只要弄明白<code>JavaScriptCore</code>在 iOS 平台上给 React Native 提供的接口也仅限于那几个接口，
React Native 剩下的魔法秘密都可以顺藤摸瓜来分析了。</p> <h2 id="二、浏览器工作原理"><a href="#二、浏览器工作原理" class="header-anchor">#</a> 二、浏览器工作原理</h2> <p>浏览器的主要作用就是通过解析 html 来形成 DOM tree，然后通过 css 来点缀和 DOM tree 上的每一个节点。</p> <h3 id="ui-层和逻辑层"><a href="#ui-层和逻辑层" class="header-anchor">#</a> UI 层和逻辑层</h3> <ol><li>html 文本描述了页面应该有哪些功能，css 告诉浏览器该长什么样。</li> <li>浏览器引擎通过解析 html 和 css ，翻译成一些列的预定义 UI 控件。</li> <li>然后 UI 控件去调用操作系统绘图指令去绘制图像展现给用户。</li> <li>JavaScript 可有可无，主要用于 html 里面一些用户事件响应，DOM 操作、异步网络请求和一些简单的计算。</li></ol> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <ul><li>React Native 中，步骤 1 和步骤 2 是不变的，也是用 html 语言描述页面有哪些功能，然后 stylesheet 告诉浏览器引擎每个控件应该长什么样。</li> <li>步骤 3 是 react native 自己实现的一套 UI 控件（两套，Android 一套，iOS 一套），这个切换是在<code>MessageQueque</code>中进行的，并且还可以发现，他们<code>tag</code>也是不一样的。</li></ul></div> <h3 id="js-在-react-native-中的作用"><a href="#js-在-react-native-中的作用" class="header-anchor">#</a> JS 在 React Native 中的作用</h3> <ul><li>它负责管理 UI component 的生命周期，管理 Virtual DOM。</li> <li>所有业务逻辑都是用 JavaScript 来实现或者衔接。</li> <li>调用原生的代码来操纵原生组件。</li> <li>JavaScript 本身是无绘图能力的，都是通过给原生组件发指令来完成。</li></ul> <h2 id="三、react-native-架构"><a href="#三、react-native-架构" class="header-anchor">#</a> 三、React Native 架构</h2> <p><img src="/images/react-native-con.jpeg" alt="React Native 架构"></p> <ul><li>绿色部分是应用开发的部分，业务逻辑代码就在这里。</li> <li>蓝色部分是跨平台的代码和引擎，一般不会改写蓝色部分。</li> <li>黄色代码平台相关的代码，做定制化的时候会添加修改代码。是各个平台用来做桥接的</li> <li>红色部分是系统平台的东西。红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了。</li></ul> <p>一般开发在绿色部分，有定制化开发需要写黄色部分。</p> <h2 id="四、react-native-react-和-javascriptcore-的关系"><a href="#四、react-native-react-和-javascriptcore-的关系" class="header-anchor">#</a> 四、React Native，React 和 JavaScriptCore 的关系</h2> <p>React 是一个纯 JS 库，所有的 React 代码和所有其它的 js 代码都需要 JS Engine 来解释执行。
React 只能做浏览器允许它做的事情, 不能调用原生接口。<strong>可以理解 JS 是一个函数，接受特定格式的字符串数据，输出计算好的字符串数据</strong>。</p> <p>JS Engine 负责调用并解析运行这个函数。</p> <h3 id="react-native-和-react-不一样"><a href="#react-native-和-react-不一样" class="header-anchor">#</a> React Native 和 React 不一样</h3> <ol><li>驱动关系不一样。
<ul><li>React 由 JavaScriptCore 来驱动。</li> <li>React Native 这里，JavaScriptCore 执行了相关的 JS 代码，然后把计算好的结果
返给<code>Native Code</code>。然后, Native code 根据 JS 计算出来的结果驱动设备上所有能驱动的硬件。
也就是说，这里 RN 可以调用所有原生的接口，所有的硬件。</li></ul></li> <li>利用 React 的 Virtual Dom 和数据驱动编程概念。简化了我们原生应用的开发， 同时，它不由浏览器去绘制，只计算出绘制指令，最终的绘制还是由原生控件去负责，保证了原生的用户体验。</li></ol> <h3 id="react-native-组件结构"><a href="#react-native-组件结构" class="header-anchor">#</a> React Native 组件结构</h3> <p>在一定程度上，React Native 和 NodeJS 有异曲同工之妙。它们都是通过扩展 JavaScript Engine, 使它具备强大的本地资源和原生接口调用能力，然后结合 JavaScript 丰富的库和社区和及其稳定的跨平台能力，
把 JavaScript 的魔力在浏览器之外的地方充分发挥出来。</p> <h3 id="javascriptcore-react-bridges-就是-react-native"><a href="#javascriptcore-react-bridges-就是-react-native" class="header-anchor">#</a> JavaScriptCore + React + Bridges 就是 React Native</h3> <ul><li>JavaScriptCore 负责 JS 代码解释执行</li> <li>React 负责描述和管理<code>Virtual DOM</code>，指挥原生组件进行绘制和更新，同时很多计算逻辑也在 js 里面进行。ReactJS 自身是不直接绘制 UI 的，UI 绘制是非常耗时的操作，原生组件最擅长这事情。</li> <li>Bridge 用来翻译 ReactJS 的绘制指令给原生组件进行绘制，同时把原生组件接收到的用户事件反馈给 React 。</li></ul> <p>要在不同的平台实现不同的效果就可以通过定制<code>Bridge</code>来实现。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>RN 厉害在于它能打通 JS 和 Native Code, 让 JS 能够调用丰富的原生接口,充分发挥硬件的能力, 实现非常复杂的效果,同时能保证效率和跨平台性。</p></div> <div class="custom-block tip"><p class="custom-block-title">Bridge 的作用</p> <ul><li>Bridge 的作用就是给 RN 内嵌的 JS Engine 提供原生接口的扩展供 JS 调用.</li> <li>每一个支持原生功能的模块不然有 JS 模块和原生模块。</li> <li>RN 中 JS 和 Native 分隔非常清晰，JS 不会直接引用 Native 层的对象实例，Native 也不会直接引用 JS 层的对象实例。</li> <li>Bridge 原生代码负责管理原生模块并生成对应的 JS 模块信息供 JS 代码调用。</li></ul></div> <h2 id="五、bridge-各模块简介"><a href="#五、bridge-各模块简介" class="header-anchor">#</a> 五、Bridge 各模块简介</h2> <h3 id="rctrootview"><a href="#rctrootview" class="header-anchor">#</a> RCTRootView</h3> <p><strong>所有 React 的绘制都会有这个 RCTRootView 来管理</strong>。RCTRootView 是 React Native 加载的地方，从这里开始，我们有了 JS Engine,
JS 代码被加载进来，对应的原生模块也被加载进来，然后 js loop 开始运行。 js loop 的驱动来源是 Timer 和 Event Loop (用户事件).
js loop 跑起来以后应用就可以持续不停地跑下去了。</p> <p>RCTRootView 做的事情如下：</p> <ul><li>创建并且持有 RCTBridge</li> <li>加载 JS Bundle 并且初始化 JS 运行环境.</li> <li>JS 运行环境准备好以后把加载视图用 RCTRootContentView 替换加载视图。</li> <li>所有准备工作就绪以后调用 AppRegistry.runApplication 正式启动 RN JS 代码。</li></ul> <h3 id="rctrootcontentview"><a href="#rctrootcontentview" class="header-anchor">#</a> RCTRootContentView</h3> <ul><li><p><code>RCTRootContentView reactTag</code>在默认情况下在 Xcode view Hierarchy debugger 下可以看到，
最顶层为<code>RCTRootView</code>, 里面嵌套的是<code>RCTRootContentView</code>, 从<code>RCTRootContentView</code>开始，每个 View 都有一个<code>reactTag</code>。</p></li> <li><p><code>RCTRootView</code>继承自<code>UIView</code>, <code>RCTRootView</code>主要负责初始化<code>JS Environment</code>和<code>React</code>代码，然后管理整个运行环境的生命周期。 <code>RCTRootContentView</code>继承自<code>RCTView</code>, <code>RCTView</code>继承自<code>UIView</code>, RCTView 封装了 React Component Node 更新和渲染的逻辑，
<code>RCTRootContentView</code>会管理所有 react ui components. <code>RCTRootContentView</code>同时负责处理所有 touch 事件。</p></li></ul> <h3 id="rctbridge"><a href="#rctbridge" class="header-anchor">#</a> RCTBridge</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这是一个加载和初始化专用类，用于前期 JS 的初始化和原生代码的加载.</p></div> <ul><li>负责加载各个 Bridge 模块供 JS 调用</li> <li>找到并注册所有实现了<code>RCTBridgeModule protocol</code>的类, 供 JS 后期使用.</li> <li>创建和持有 <code>RCTBatchedBridge</code></li></ul> <h3 id="rctbatchedbridge"><a href="#rctbatchedbridge" class="header-anchor">#</a> RCTBatchedBridge</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>RCTBridge</code> 和 <code>RCTBatchedBridge</code>,前者负责发号施令，后者负责实施</p></div> <ul><li>负责<code>Native</code>和 JS 之间的相互调用(消息通信)</li> <li>持有<code>JSExecutor</code></li> <li>实例化所有在<code>RCTBridge</code>里面注册了的<code>native node_modules</code></li> <li>创建 JS 运行环境， 注入 <code>native hooks</code> 和<code>modules</code>， 执行 <code>JS bundle script</code>。</li> <li>管理 JS run loop , 批量把所有 JS 到 native 的调用翻译成<code>native invocations</code></li> <li>批量管理原生代码到 JS 的调用，把这些调用翻译成 JS 消息发送给<code>JS executor</code></li></ul> <h3 id="rctjavascriptloader"><a href="#rctjavascriptloader" class="header-anchor">#</a> RCTJavaScriptLoader</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这是实现远程代码加载的核心。热更新，开发环境代码加载，静态 jsbundle 加载都离不开这个工具。</p></div> <ul><li>从指定的地方(bundle, http server)加载 script bundle</li> <li>把加载完成的脚本用 string 的形式返回</li> <li>处理所有获取代码、打包代码时遇到的错误</li></ul> <h3 id="rctcontextexecutor"><a href="#rctcontextexecutor" class="header-anchor">#</a> RCTContextExecutor</h3> <ul><li>封装了基础的 JS 和原生代码互掉和管理逻辑，是 JS 引擎切换的基础。
通过不同的<code>RCTCOntextExecutor</code>来适配不同的<code>JS Engine</code>，让我们的 React JS 可以在 iOS、Android、chrome 甚至是自定义的 js engine 里面执行。
这也是为何我们能在 chrome 里面直接调试 js 代码的原因。</li> <li>管理和执行所有 N2J 调用。</li></ul> <h3 id="rctmoduledata"><a href="#rctmoduledata" class="header-anchor">#</a> RCTModuleData</h3> <ul><li>加载和管理所有和 JS 有交互的原生代码。把需要和 JS 交互的代码按照一定的规则自动封装成 JS 模块</li> <li>收集所有桥接模块的信息，供注入到 JS 运行环境</li></ul> <h3 id="rctmodulemethod"><a href="#rctmodulemethod" class="header-anchor">#</a> RCTModuleMethod</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>记录所有原生代码的导出函数地址( JS 里面是不能直接持有原生对象的)，同时生成对应的字符串映射到该函数地址。
JS 调用原生函数的时候会通过 message 的形式调用过来</p></div> <ul><li>记录所有的原生代码的函数地址，并且生成对应的字符串映射到该地址</li> <li>记录所有的 block 的地址并且映射到唯一的一个 id</li> <li>翻译所有<code>J2N call</code>，然后执行对应的 native 方法</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <ul><li>如果是原生方法的调用则直接通过方法名调用，MessageQueue 会帮忙把 Method 翻译成 MethodID, 然后转发消息给原生代码，传递函数签名和参数给原生 MessageQueue, 最终给 RCTModuleMethod 解析调用最终的方法</li> <li>如果 JS 调用的是一个回调 block，MessageQueue 会把回调对象转化成一个一次性的 block id, 然后传递给 RCTModuleMethod, 最终由 RCTModuleMethod 解析调用。基本上和方法调用一样，只不过生命周期会不一样，block 是动态生成的，要及时销毁，要不然会导致内存泄漏</li></ul></div> <h3 id="messagequeue"><a href="#messagequeue" class="header-anchor">#</a> MessageQueue</h3> <ul><li>这是核心中的核心。整个<code>react native</code>对浏览器内核是未做任何定制的，完全依赖浏览器内核的标准接口在运作。它怎么实现 UI 的完全定制的呢？它实际上未使用浏览器内核的任何 UI 绘制功能，注意是未使用 UI 绘制功能。它利用 javascript 引擎强大的 DOM 操作管理能力来管理所有 UI 节点，每次刷新前把所有节点信息更新完毕以后再给 yoga 做排版，然后再调用原生组件来绘制。 javascript 是整个系统的核心语言。</li> <li>我们可以把浏览器看成一个盒子，javascript 引擎是盒子里面的总管，DOM 是 javascript 引擎内置的，javascript 和 javascript 引擎也是无缝链接的。react native 是怎么跳出这个盒子去调用外部原生组件来绘制 UI 的呢？秘密就在 MessageQueue。</li> <li>Javascript 引擎对原生代码的调用都是通过一套固定的接口来实现，这套接口的主要作用就是记录原生接口的地址和对应的 javascript 的函数名称，然后在 javascript 调用该函数的时候把调用转发给原生接口</li></ul> <h2 id="六、相关链接"><a href="#六、相关链接" class="header-anchor">#</a> 六、相关链接</h2> <ul><li><a href="http://blog.poetries.top/2019/10/02/rn-yuanli/" target="_blank" rel="noopener noreferrer">RN 原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/6844903553283129352" target="_blank" rel="noopener noreferrer">React Native for Android 原理分析与实践：实现原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.jianshu.com/p/e220e1f34a0b" target="_blank" rel="noopener noreferrer">深入剖析 JavaScriptCore<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/henryfordstick/edit/master/docs/blog/react-native-principle.md" target="_blank" rel="noopener noreferrer">本文源码地址</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">11/8/2020, 12:01:14 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.596f9c08.js" defer></script><script src="/assets/js/2.55845630.js" defer></script><script src="/assets/js/33.621a195e.js" defer></script><script src="/assets/js/3.e0f79c9f.js" defer></script>
  </body>
</html>
