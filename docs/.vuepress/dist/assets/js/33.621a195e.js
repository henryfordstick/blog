(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{396:function(t,e,a){"use strict";a.r(e);var v=a(27),i=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-native-原理浅析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-native-原理浅析"}},[t._v("#")]),t._v(" React Native 原理浅析")]),t._v(" "),a("p",[t._v("这章来讲讲 React Native 的原理，来揭开它的神秘面纱！")]),t._v(" "),a("ul",[a("li",[t._v("一、JavaScriptCore")]),t._v(" "),a("li",[t._v("二、浏览器工作原理")]),t._v(" "),a("li",[t._v("三、React Native 架构")]),t._v(" "),a("li",[t._v("四、React Native，React 和 JavaScriptCore 的关系")]),t._v(" "),a("li",[t._v("五、Bridge 各模块简介")]),t._v(" "),a("li",[t._v("六、相关链接")])]),t._v(" "),a("p",[t._v("关于 React Native 的更新，可以查看"),a("a",{attrs:{href:"https://juejin.im/post/6844904146840059918",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS 核心理论之《 原理浅析》"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"一、javascriptcore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、javascriptcore"}},[t._v("#")]),t._v(" 一、JavaScriptCore")]),t._v(" "),a("p",[t._v("为什么要说 JS Engine 呢？"),a("strong",[t._v("因为 React Native 的核心代码都是用 JS 来写的，没有 JS Engine，\n那么我们所写的 JS 和 JSX 代码都无法执行，更无法驱动 Native 的 API 了")]),t._v("。\n"),a("code",[t._v("JavaScriptCore")]),t._v("是 iOS 设备默认支持的，是 Webkit 默认的 JS 引擎，所以 iOS 和 Android 都支持。")]),t._v(" "),a("p",[t._v("现在只要弄明白"),a("code",[t._v("JavaScriptCore")]),t._v("在 iOS 平台上给 React Native 提供的接口也仅限于那几个接口，\nReact Native 剩下的魔法秘密都可以顺藤摸瓜来分析了。")]),t._v(" "),a("h2",{attrs:{id:"二、浏览器工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、浏览器工作原理"}},[t._v("#")]),t._v(" 二、浏览器工作原理")]),t._v(" "),a("p",[t._v("浏览器的主要作用就是通过解析 html 来形成 DOM tree，然后通过 css 来点缀和 DOM tree 上的每一个节点。")]),t._v(" "),a("h3",{attrs:{id:"ui-层和逻辑层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ui-层和逻辑层"}},[t._v("#")]),t._v(" UI 层和逻辑层")]),t._v(" "),a("ol",[a("li",[t._v("html 文本描述了页面应该有哪些功能，css 告诉浏览器该长什么样。")]),t._v(" "),a("li",[t._v("浏览器引擎通过解析 html 和 css ，翻译成一些列的预定义 UI 控件。")]),t._v(" "),a("li",[t._v("然后 UI 控件去调用操作系统绘图指令去绘制图像展现给用户。")]),t._v(" "),a("li",[t._v("JavaScript 可有可无，主要用于 html 里面一些用户事件响应，DOM 操作、异步网络请求和一些简单的计算。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("ul",[a("li",[t._v("React Native 中，步骤 1 和步骤 2 是不变的，也是用 html 语言描述页面有哪些功能，然后 stylesheet 告诉浏览器引擎每个控件应该长什么样。")]),t._v(" "),a("li",[t._v("步骤 3 是 react native 自己实现的一套 UI 控件（两套，Android 一套，iOS 一套），这个切换是在"),a("code",[t._v("MessageQueque")]),t._v("中进行的，并且还可以发现，他们"),a("code",[t._v("tag")]),t._v("也是不一样的。")])])]),t._v(" "),a("h3",{attrs:{id:"js-在-react-native-中的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-在-react-native-中的作用"}},[t._v("#")]),t._v(" JS 在 React Native 中的作用")]),t._v(" "),a("ul",[a("li",[t._v("它负责管理 UI component 的生命周期，管理 Virtual DOM。")]),t._v(" "),a("li",[t._v("所有业务逻辑都是用 JavaScript 来实现或者衔接。")]),t._v(" "),a("li",[t._v("调用原生的代码来操纵原生组件。")]),t._v(" "),a("li",[t._v("JavaScript 本身是无绘图能力的，都是通过给原生组件发指令来完成。")])]),t._v(" "),a("h2",{attrs:{id:"三、react-native-架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、react-native-架构"}},[t._v("#")]),t._v(" 三、React Native 架构")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/react-native-con.jpeg",alt:"React Native 架构"}})]),t._v(" "),a("ul",[a("li",[t._v("绿色部分是应用开发的部分，业务逻辑代码就在这里。")]),t._v(" "),a("li",[t._v("蓝色部分是跨平台的代码和引擎，一般不会改写蓝色部分。")]),t._v(" "),a("li",[t._v("黄色代码平台相关的代码，做定制化的时候会添加修改代码。是各个平台用来做桥接的")]),t._v(" "),a("li",[t._v("红色部分是系统平台的东西。红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了。")])]),t._v(" "),a("p",[t._v("一般开发在绿色部分，有定制化开发需要写黄色部分。")]),t._v(" "),a("h2",{attrs:{id:"四、react-native-react-和-javascriptcore-的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、react-native-react-和-javascriptcore-的关系"}},[t._v("#")]),t._v(" 四、React Native，React 和 JavaScriptCore 的关系")]),t._v(" "),a("p",[t._v("React 是一个纯 JS 库，所有的 React 代码和所有其它的 js 代码都需要 JS Engine 来解释执行。\nReact 只能做浏览器允许它做的事情, 不能调用原生接口。"),a("strong",[t._v("可以理解 JS 是一个函数，接受特定格式的字符串数据，输出计算好的字符串数据")]),t._v("。")]),t._v(" "),a("p",[t._v("JS Engine 负责调用并解析运行这个函数。")]),t._v(" "),a("h3",{attrs:{id:"react-native-和-react-不一样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-native-和-react-不一样"}},[t._v("#")]),t._v(" React Native 和 React 不一样")]),t._v(" "),a("ol",[a("li",[t._v("驱动关系不一样。\n"),a("ul",[a("li",[t._v("React 由 JavaScriptCore 来驱动。")]),t._v(" "),a("li",[t._v("React Native 这里，JavaScriptCore 执行了相关的 JS 代码，然后把计算好的结果\n返给"),a("code",[t._v("Native Code")]),t._v("。然后, Native code 根据 JS 计算出来的结果驱动设备上所有能驱动的硬件。\n也就是说，这里 RN 可以调用所有原生的接口，所有的硬件。")])])]),t._v(" "),a("li",[t._v("利用 React 的 Virtual Dom 和数据驱动编程概念。简化了我们原生应用的开发， 同时，它不由浏览器去绘制，只计算出绘制指令，最终的绘制还是由原生控件去负责，保证了原生的用户体验。")])]),t._v(" "),a("h3",{attrs:{id:"react-native-组件结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-native-组件结构"}},[t._v("#")]),t._v(" React Native 组件结构")]),t._v(" "),a("p",[t._v("在一定程度上，React Native 和 NodeJS 有异曲同工之妙。它们都是通过扩展 JavaScript Engine, 使它具备强大的本地资源和原生接口调用能力，然后结合 JavaScript 丰富的库和社区和及其稳定的跨平台能力，\n把 JavaScript 的魔力在浏览器之外的地方充分发挥出来。")]),t._v(" "),a("h3",{attrs:{id:"javascriptcore-react-bridges-就是-react-native"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascriptcore-react-bridges-就是-react-native"}},[t._v("#")]),t._v(" JavaScriptCore + React + Bridges 就是 React Native")]),t._v(" "),a("ul",[a("li",[t._v("JavaScriptCore 负责 JS 代码解释执行")]),t._v(" "),a("li",[t._v("React 负责描述和管理"),a("code",[t._v("Virtual DOM")]),t._v("，指挥原生组件进行绘制和更新，同时很多计算逻辑也在 js 里面进行。ReactJS 自身是不直接绘制 UI 的，UI 绘制是非常耗时的操作，原生组件最擅长这事情。")]),t._v(" "),a("li",[t._v("Bridge 用来翻译 ReactJS 的绘制指令给原生组件进行绘制，同时把原生组件接收到的用户事件反馈给 React 。")])]),t._v(" "),a("p",[t._v("要在不同的平台实现不同的效果就可以通过定制"),a("code",[t._v("Bridge")]),t._v("来实现。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("RN 厉害在于它能打通 JS 和 Native Code, 让 JS 能够调用丰富的原生接口,充分发挥硬件的能力, 实现非常复杂的效果,同时能保证效率和跨平台性。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Bridge 的作用")]),t._v(" "),a("ul",[a("li",[t._v("Bridge 的作用就是给 RN 内嵌的 JS Engine 提供原生接口的扩展供 JS 调用.")]),t._v(" "),a("li",[t._v("每一个支持原生功能的模块不然有 JS 模块和原生模块。")]),t._v(" "),a("li",[t._v("RN 中 JS 和 Native 分隔非常清晰，JS 不会直接引用 Native 层的对象实例，Native 也不会直接引用 JS 层的对象实例。")]),t._v(" "),a("li",[t._v("Bridge 原生代码负责管理原生模块并生成对应的 JS 模块信息供 JS 代码调用。")])])]),t._v(" "),a("h2",{attrs:{id:"五、bridge-各模块简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、bridge-各模块简介"}},[t._v("#")]),t._v(" 五、Bridge 各模块简介")]),t._v(" "),a("h3",{attrs:{id:"rctrootview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctrootview"}},[t._v("#")]),t._v(" RCTRootView")]),t._v(" "),a("p",[a("strong",[t._v("所有 React 的绘制都会有这个 RCTRootView 来管理")]),t._v("。RCTRootView 是 React Native 加载的地方，从这里开始，我们有了 JS Engine,\nJS 代码被加载进来，对应的原生模块也被加载进来，然后 js loop 开始运行。 js loop 的驱动来源是 Timer 和 Event Loop (用户事件).\njs loop 跑起来以后应用就可以持续不停地跑下去了。")]),t._v(" "),a("p",[t._v("RCTRootView 做的事情如下：")]),t._v(" "),a("ul",[a("li",[t._v("创建并且持有 RCTBridge")]),t._v(" "),a("li",[t._v("加载 JS Bundle 并且初始化 JS 运行环境.")]),t._v(" "),a("li",[t._v("JS 运行环境准备好以后把加载视图用 RCTRootContentView 替换加载视图。")]),t._v(" "),a("li",[t._v("所有准备工作就绪以后调用 AppRegistry.runApplication 正式启动 RN JS 代码。")])]),t._v(" "),a("h3",{attrs:{id:"rctrootcontentview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctrootcontentview"}},[t._v("#")]),t._v(" RCTRootContentView")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("RCTRootContentView reactTag")]),t._v("在默认情况下在 Xcode view Hierarchy debugger 下可以看到，\n最顶层为"),a("code",[t._v("RCTRootView")]),t._v(", 里面嵌套的是"),a("code",[t._v("RCTRootContentView")]),t._v(", 从"),a("code",[t._v("RCTRootContentView")]),t._v("开始，每个 View 都有一个"),a("code",[t._v("reactTag")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("RCTRootView")]),t._v("继承自"),a("code",[t._v("UIView")]),t._v(", "),a("code",[t._v("RCTRootView")]),t._v("主要负责初始化"),a("code",[t._v("JS Environment")]),t._v("和"),a("code",[t._v("React")]),t._v("代码，然后管理整个运行环境的生命周期。 "),a("code",[t._v("RCTRootContentView")]),t._v("继承自"),a("code",[t._v("RCTView")]),t._v(", "),a("code",[t._v("RCTView")]),t._v("继承自"),a("code",[t._v("UIView")]),t._v(", RCTView 封装了 React Component Node 更新和渲染的逻辑，\n"),a("code",[t._v("RCTRootContentView")]),t._v("会管理所有 react ui components. "),a("code",[t._v("RCTRootContentView")]),t._v("同时负责处理所有 touch 事件。")])])]),t._v(" "),a("h3",{attrs:{id:"rctbridge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctbridge"}},[t._v("#")]),t._v(" RCTBridge")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("这是一个加载和初始化专用类，用于前期 JS 的初始化和原生代码的加载.")])]),t._v(" "),a("ul",[a("li",[t._v("负责加载各个 Bridge 模块供 JS 调用")]),t._v(" "),a("li",[t._v("找到并注册所有实现了"),a("code",[t._v("RCTBridgeModule protocol")]),t._v("的类, 供 JS 后期使用.")]),t._v(" "),a("li",[t._v("创建和持有 "),a("code",[t._v("RCTBatchedBridge")])])]),t._v(" "),a("h3",{attrs:{id:"rctbatchedbridge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctbatchedbridge"}},[t._v("#")]),t._v(" RCTBatchedBridge")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[a("code",[t._v("RCTBridge")]),t._v(" 和 "),a("code",[t._v("RCTBatchedBridge")]),t._v(",前者负责发号施令，后者负责实施")])]),t._v(" "),a("ul",[a("li",[t._v("负责"),a("code",[t._v("Native")]),t._v("和 JS 之间的相互调用(消息通信)")]),t._v(" "),a("li",[t._v("持有"),a("code",[t._v("JSExecutor")])]),t._v(" "),a("li",[t._v("实例化所有在"),a("code",[t._v("RCTBridge")]),t._v("里面注册了的"),a("code",[t._v("native node_modules")])]),t._v(" "),a("li",[t._v("创建 JS 运行环境， 注入 "),a("code",[t._v("native hooks")]),t._v(" 和"),a("code",[t._v("modules")]),t._v("， 执行 "),a("code",[t._v("JS bundle script")]),t._v("。")]),t._v(" "),a("li",[t._v("管理 JS run loop , 批量把所有 JS 到 native 的调用翻译成"),a("code",[t._v("native invocations")])]),t._v(" "),a("li",[t._v("批量管理原生代码到 JS 的调用，把这些调用翻译成 JS 消息发送给"),a("code",[t._v("JS executor")])])]),t._v(" "),a("h3",{attrs:{id:"rctjavascriptloader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctjavascriptloader"}},[t._v("#")]),t._v(" RCTJavaScriptLoader")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("这是实现远程代码加载的核心。热更新，开发环境代码加载，静态 jsbundle 加载都离不开这个工具。")])]),t._v(" "),a("ul",[a("li",[t._v("从指定的地方(bundle, http server)加载 script bundle")]),t._v(" "),a("li",[t._v("把加载完成的脚本用 string 的形式返回")]),t._v(" "),a("li",[t._v("处理所有获取代码、打包代码时遇到的错误")])]),t._v(" "),a("h3",{attrs:{id:"rctcontextexecutor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctcontextexecutor"}},[t._v("#")]),t._v(" RCTContextExecutor")]),t._v(" "),a("ul",[a("li",[t._v("封装了基础的 JS 和原生代码互掉和管理逻辑，是 JS 引擎切换的基础。\n通过不同的"),a("code",[t._v("RCTCOntextExecutor")]),t._v("来适配不同的"),a("code",[t._v("JS Engine")]),t._v("，让我们的 React JS 可以在 iOS、Android、chrome 甚至是自定义的 js engine 里面执行。\n这也是为何我们能在 chrome 里面直接调试 js 代码的原因。")]),t._v(" "),a("li",[t._v("管理和执行所有 N2J 调用。")])]),t._v(" "),a("h3",{attrs:{id:"rctmoduledata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctmoduledata"}},[t._v("#")]),t._v(" RCTModuleData")]),t._v(" "),a("ul",[a("li",[t._v("加载和管理所有和 JS 有交互的原生代码。把需要和 JS 交互的代码按照一定的规则自动封装成 JS 模块")]),t._v(" "),a("li",[t._v("收集所有桥接模块的信息，供注入到 JS 运行环境")])]),t._v(" "),a("h3",{attrs:{id:"rctmodulemethod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rctmodulemethod"}},[t._v("#")]),t._v(" RCTModuleMethod")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("记录所有原生代码的导出函数地址( JS 里面是不能直接持有原生对象的)，同时生成对应的字符串映射到该函数地址。\nJS 调用原生函数的时候会通过 message 的形式调用过来")])]),t._v(" "),a("ul",[a("li",[t._v("记录所有的原生代码的函数地址，并且生成对应的字符串映射到该地址")]),t._v(" "),a("li",[t._v("记录所有的 block 的地址并且映射到唯一的一个 id")]),t._v(" "),a("li",[t._v("翻译所有"),a("code",[t._v("J2N call")]),t._v("，然后执行对应的 native 方法")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("ul",[a("li",[t._v("如果是原生方法的调用则直接通过方法名调用，MessageQueue 会帮忙把 Method 翻译成 MethodID, 然后转发消息给原生代码，传递函数签名和参数给原生 MessageQueue, 最终给 RCTModuleMethod 解析调用最终的方法")]),t._v(" "),a("li",[t._v("如果 JS 调用的是一个回调 block，MessageQueue 会把回调对象转化成一个一次性的 block id, 然后传递给 RCTModuleMethod, 最终由 RCTModuleMethod 解析调用。基本上和方法调用一样，只不过生命周期会不一样，block 是动态生成的，要及时销毁，要不然会导致内存泄漏")])])]),t._v(" "),a("h3",{attrs:{id:"messagequeue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#messagequeue"}},[t._v("#")]),t._v(" MessageQueue")]),t._v(" "),a("ul",[a("li",[t._v("这是核心中的核心。整个"),a("code",[t._v("react native")]),t._v("对浏览器内核是未做任何定制的，完全依赖浏览器内核的标准接口在运作。它怎么实现 UI 的完全定制的呢？它实际上未使用浏览器内核的任何 UI 绘制功能，注意是未使用 UI 绘制功能。它利用 javascript 引擎强大的 DOM 操作管理能力来管理所有 UI 节点，每次刷新前把所有节点信息更新完毕以后再给 yoga 做排版，然后再调用原生组件来绘制。 javascript 是整个系统的核心语言。")]),t._v(" "),a("li",[t._v("我们可以把浏览器看成一个盒子，javascript 引擎是盒子里面的总管，DOM 是 javascript 引擎内置的，javascript 和 javascript 引擎也是无缝链接的。react native 是怎么跳出这个盒子去调用外部原生组件来绘制 UI 的呢？秘密就在 MessageQueue。")]),t._v(" "),a("li",[t._v("Javascript 引擎对原生代码的调用都是通过一套固定的接口来实现，这套接口的主要作用就是记录原生接口的地址和对应的 javascript 的函数名称，然后在 javascript 调用该函数的时候把调用转发给原生接口")])]),t._v(" "),a("h2",{attrs:{id:"六、相关链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、相关链接"}},[t._v("#")]),t._v(" 六、相关链接")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://blog.poetries.top/2019/10/02/rn-yuanli/",target:"_blank",rel:"noopener noreferrer"}},[t._v("RN 原理"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/6844903553283129352",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Native for Android 原理分析与实践：实现原理"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.jianshu.com/p/e220e1f34a0b",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入剖析 JavaScriptCore"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=i.exports}}]);