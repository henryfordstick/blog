(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{402:function(t,a,e){"use strict";e.r(a);var v=e(27),i=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-native-使用总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-使用总结"}},[t._v("#")]),t._v(" React Native 使用总结")]),t._v(" "),e("ul",[e("li",[t._v("了解 App 分类")]),t._v(" "),e("li",[t._v("React Native 框架工作原理")]),t._v(" "),e("li",[t._v("React Native 运行原理")]),t._v(" "),e("li",[t._v("React Native 性能调优")])]),t._v(" "),e("h2",{attrs:{id:"了解-app-分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#了解-app-分类"}},[t._v("#")]),t._v(" 了解 App 分类")]),t._v(" "),e("p",[t._v("目前 App 的技术栈可以分为四类：")]),t._v(" "),e("h4",{attrs:{id:"web-app-技术栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-app-技术栈"}},[t._v("#")]),t._v(" Web App 技术栈")]),t._v(" "),e("p",[t._v("指使用 Html 开发的移动端网页 App ,类似微信小程序，整个 App 都是网页。")]),t._v(" "),e("ul",[e("li",[t._v("优点：用户不需要安装，不会占用手机内存。")]),t._v(" "),e("li",[t._v("缺点：用户体验不好，不能离线，必须联网。")])]),t._v(" "),e("h4",{attrs:{id:"混合-app-技术栈-hybrid-app"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#混合-app-技术栈-hybrid-app"}},[t._v("#")]),t._v(" 混合 App 技术栈 （Hybrid App）")]),t._v(" "),e("p",[t._v("混合技术栈指的是开发混合 App 的技术，也就是把 Web 网页放到特定的容器中，然后再打包成各个平台的原生 App。所以，混合技术栈其实是 Web 技术栈 + 容器技术栈，典型代表是 PhoneGap、Cordova、Ionic 等框架。")]),t._v(" "),e("ul",[e("li",[t._v("优点：界面复用性强，一个界面， iOS 和安卓都可以使用")]),t._v(" "),e("li",[t._v("缺点：相对于原生，性能相对有所损害")])]),t._v(" "),e("h4",{attrs:{id:"跨平台-app-技术栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跨平台-app-技术栈"}},[t._v("#")]),t._v(" 跨平台 App 技术栈")]),t._v(" "),e("p",[t._v("跨平台技术栈指的是使用一种技术，同时支持多个手机平台。它与混合技术栈的区别是，不使用 Web 技术，即它的页面不是 HTML5 页面，而是使用自己的语法写的 UI 层，然后编译成各平台的原生 App。")]),t._v(" "),e("p",[t._v("这个技术栈就是纯粹的容器技术栈，React Native、Xamarin、Flutter 都属于这一类。学习时，除了学习容器的 API Bridge，还要学习容器提供的 UI 层，即怎么写页面。")]),t._v(" "),e("ul",[e("li",[t._v("优点：\n"),e("ul",[e("li",[t._v("跨平台开发")]),t._v(" "),e("li",[t._v("跳过 App Store 审核，远程更新代码，提高迭代频率和效率，既有 Native 的体验，又保留 React 的开发效率。")])])]),t._v(" "),e("li",[t._v("缺点：不能真正意义上做到跨平台，使用后，对 app 体积增加。")])]),t._v(" "),e("h4",{attrs:{id:"原生-app-技术栈-native-app"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原生-app-技术栈-native-app"}},[t._v("#")]),t._v(" 原生 App 技术栈 （Native App）")]),t._v(" "),e("p",[t._v("原生技术栈指的是，只能用于特定手机平台的开发技术。比如，安卓平台的 Java 技术栈，iOS 平台的 Object-C 技术栈或 Swift 技术栈。")]),t._v(" "),e("ul",[e("li",[t._v("优点：性能高")]),t._v(" "),e("li",[t._v("缺点：开发维护成本高，这种技术栈只能用在一个平台，不能跨平台。最重要 iOS 版本更新也成问题。")])]),t._v(" "),e("h2",{attrs:{id:"react-native-框架工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-框架工作原理"}},[t._v("#")]),t._v(" React Native 框架工作原理")]),t._v(" "),e("h3",{attrs:{id:"react-native-渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-渲染"}},[t._v("#")]),t._v(" React Native 渲染")]),t._v(" "),e("p",[t._v("在浏览器中，React 的 JSX 源码通过 React 框架最终渲染成真实的 DOM 。")]),t._v(" "),e("p",[t._v("而在 React Native 框架中，JSX 源码通过 React Native 框架编译后，通过对应平台的 Bridge 实现了与原生框架的通信。")]),t._v(" "),e("img",{staticStyle:{"margin-right":"10%"},attrs:{src:"/images/rn-ui.jpg",width:"40%"}}),t._v(" "),e("img",{attrs:{src:"/images/rn-ui1.jpg",width:"40%"}}),t._v("\n如果我们程序中调用了 React Native 提供的 API ，那么 React Native 框架就通过 Bridge 调用原生框架中的方法。\n"),e("p",[t._v("React Native 的底层为 React 框架，所以，如果是 UI 层的变更，那么就\n映射为虚拟 DOM 后调用 diff 算法计算出变动后的 JSON 映射文件，最终由 Native\n层将此 JSON 文件映射渲染到原生 App 的页面元素上，实现了在项目中只需控制\nstate 以及 props 变更来引起 iOS Android 平台的 UI 变更。")]),t._v(" "),e("h3",{attrs:{id:"react-native-与原生平台通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-与原生平台通信"}},[t._v("#")]),t._v(" React Native 与原生平台通信")]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/rn-bridge.jpg",alt:"react native 桥接"}}),t._v("\nReact Native 与原生框架通信中，采用了 JavaScriptCore 作为\nJS VM ，中间通过 JSON 文件与 Bridge 行通信,"),e("strong",[t._v("若使用 Chrome 浏览器进行调\n试，那么所有的 JavaScript 代码都将运行在 Chrome 的 V8 引擎中，与原生代码通过\nWebSocket 进行通信")]),t._v("。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("生命周期")]),t._v(" "),e("p",[t._v("React Native 的生命周期和 React 是一样的。")])]),t._v(" "),e("h2",{attrs:{id:"react-native-运行原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-运行原理"}},[t._v("#")]),t._v(" React Native 运行原理")]),t._v(" "),e("p",[t._v("React Native 框架运行起来所依赖的几大组成部分：")]),t._v(" "),e("ul",[e("li",[t._v("硬件设备或模拟器，用于运行原生代码。")]),t._v(" "),e("li",[t._v("Node js 务端，也就是 React Native Packager ，负责源码的打包工作；")]),t._v(" "),e("li",[t._v("Google Chrome，可以提供中间态的调试工具；")]),t._v(" "),e("li",[t._v("后台的 React Native JavaScript 代码；")])]),t._v(" "),e("h4",{attrs:{id:"react-native-packager-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-packager-实现原理"}},[t._v("#")]),t._v(" React Native Packager 实现原理")]),t._v(" "),e("p",[t._v("启动 React Native 项目时，React Native 框架会自动启动 React Native Packager 控制台来进行监昕与打包。")]),t._v(" "),e("blockquote",[e("p",[t._v("更改端口号 "),e("code",[t._v("react native start -- port=8088")])]),t._v(" "),e("p",[t._v("项目初始化 "),e("code",[t._v("react-native init --verbose")])])]),t._v(" "),e("h2",{attrs:{id:"react-native-性能调优"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-性能调优"}},[t._v("#")]),t._v(" React Native 性能调优")]),t._v(" "),e("p",[t._v("首先，补一下基础的概念。我们的使用 App 时为什么觉得它很卡呢？")]),t._v(" "),e("p",[t._v("一个动态图像的显示，是由很多"),e("strong",[t._v("帧")]),t._v("构成，也就是连续变化。而一帧是值一张画面，一秒钟显示的画面数就是\n"),e("strong",[t._v("帧频（FPS）")]),t._v("。 如 iOS 设备提供的 FPS 是 60 ，也就是一秒钟跑 60 个画面。")]),t._v(" "),e("h3",{attrs:{id:"react-native-性能监控工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-native-性能监控工具"}},[t._v("#")]),t._v(" React Native 性能监控工具")]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/PerfUtil.png",alt:"性能监控"}})]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("名称")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("RAM")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("内存占用")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("JSC")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("JavaScript 堆占用")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("Views")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("上面的数字是当前屏幕所有 view 的数量，下面的数字是当前组件所有 view 的数量")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("UI")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("FPS (帧频)")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("JS")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("JavaScript 帧频")])])])]),t._v(" "),e("h3",{attrs:{id:"常见性能低的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见性能低的原因"}},[t._v("#")]),t._v(" 常见性能低的原因")]),t._v(" "),e("ul",[e("li",[t._v("console.log 语句会占用 JavaScript 的线程资源，\n"),e("ul",[e("li",[t._v("可以通过"),e("code",[t._v("__DEV__")]),t._v("来判断是开发环境，还是生产环境。")]),t._v(" "),e("li",[t._v("配置 babel 插件"),e("code",[t._v("babel-plugin-transform-remove-console")]),t._v("实现自动替换。")])])]),t._v(" "),e("li",[t._v("Navigator 性能问题，使用"),e("code",[t._v("React-Navigation")]),t._v("，其视图使用了原生组件，并使用了"),e("code",[t._v("Animated")]),t._v("内库。保证了动画效果。")]),t._v(" "),e("li",[t._v("Touchable 类组件使用问题，将点击事件包裹在"),e("code",[t._v("requestAnimationFrame")]),t._v("中。")]),t._v(" "),e("li",[t._v("改变图片大小导致掉帧问题\n-定义样式 "),e("code",[t._v("transform [ {scale ｝")])]),t._v(" "),e("li",[t._v("改变视图时导致丢帧问题")]),t._v(" "),e("li",[t._v("ListView 组件性能问题")]),t._v(" "),e("li",[t._v("在重绘一个没有改变的视图时 JS 的 FPS 突然下降\n"),e("code",[t._v("shouldComponentUpdate")]),t._v("中定义数据更新的条件。")]),t._v(" "),e("li",[t._v("JavaScript 线程繁忙时导致 JS 线程掉帧\n"),e("ul",[e("li",[t._v("Navigator 切换较慢就是此问题的一种表 可通过使用 InteractionManager 来\n解决，而在动画中，可以通过使用 LayoutAnimation 来解决。")])])])])])}),[],!1,null,null,null);a.default=i.exports}}]);